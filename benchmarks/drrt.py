import os
import sys
import networkx as nx
from discopygal.solvers.nearest_neighbors import NearestNeighbors_sklearn

from metrics.ctd_metric import Metric_CTD
from metrics.epsilon_metric import Metric_Epsilon_2, Metric_Epsilon_Inf
from metrics.euclidean_metric import Metric_Euclidean
from metrics.max_l2_metric import Metric_Max_L2
from utils.nearest_neighbors import NearestNeighbors_sklearn_ball

dir = os.path.abspath(__file__)
dir = dir.split('/')[0:-2]
dir = '/'.join(dir)
sys.path.insert(0,dir)

from discopygal.solvers import RobotRod, Scene
from discopygal.solvers import PathPoint, Path, PathCollection
from discopygal.solvers.samplers import Sampler_Uniform
from discopygal.bindings import *
from discopygal.geometry_utils import conversions
from discopygal.solvers.Solver import Solver

from utils.tensor_roadmap import TensorRoadmap, build_probabilistic_roadmap
from discopygal.solvers.rrt.drrt import dRRT

class dRRT(Solver):
    """
    Implementation of the dRRT algorithm for multi-robot motion planning.
    This is done by generating PRMs for each robot seperatly, and then running RRT where
    we only add valid vertices and edges in the tensor roadmap generated by the tensor product
    of the individual roadmaps.

    :param num_landmarks: number of landmarks to sample in the tensor roadmap
    :type num_landmarks: :class:`int`
    :param prm_num_landmarks: number of landmarks to sample in each robot's PRM
    :type prm_num_landmarks: :class:`int`
    :param prm_k: number of nearest neighbors to connect for PRM
    :type prm_k: :class:`int`
    :param nearest_neighbors: a nearest neighbors algorithm *for the tensor roadmap*. if None then use sklearn implementation
    :type nearest_neighbors: :class:`~discopygal.solvers.nearest_neighbors.NearestNeighbors` or :class:`None`
    :param prm_nearest_neighbors: a nearest neighbors algorithm *for the PRM*. if None then use sklearn implementation
    :type prm_nearest_neighbors: :class:`~discopygal.solvers.nearest_neighbors.NearestNeighbors` or :class:`None`
    :param metric: a metric for choosing best edge, can be different then the nearest_neighbors metric!
        If None then use euclidean metric
    :type metric: :class:`~discopygal.solvers.metrics.Metric` or :class:`None`
    :param sampler: sampling algorithm/method. if None then use uniform sampling
    :type sampler: :class:`~discopygal.solvers.samplers.Sampler`

    """

    def __init__(self, num_landmarks, prm_num_landmarks, prm_k,
                 bounding_margin_width_factor=Solver.DEFAULT_BOUNDS_MARGIN_FACTOR
                  ,metric=None, sampler=None, prm_nearest_neighbors=None, roadmap_nearest_neighbors =None):
        super().__init__(bounding_margin_width_factor)
        self.num_landmarks = num_landmarks
        self.prm_num_landmarks = prm_num_landmarks
        self.prm_k = prm_k

        self.prm_nearest_neighbors = prm_nearest_neighbors
        self.nearest_neighbors = roadmap_nearest_neighbors
        self.metric = metric

        self.sampler = sampler
        if self.sampler is None:
            self.sampler = Sampler_Uniform()

        self.tensor_roadmap = None

    @staticmethod
    def get_arguments():
        """
        Return a list of arguments and their description, defaults and types.
        Can be used by a GUI to generate fields dynamically.
        Should be overridded by solvers.

        :return: arguments dict
        :rtype: :class:`dict`
        """
        return {
            'num_landmarks': ('Number of Landmarks (in dRRT):', 1000, int),
            'prm_num_landmarks': ('Number of Landmarks (in PRM):', 2000, int),
            'prm_k': ('K for nearest neighbors:', 15, int),
            'bounding_margin_width_factor': (
            'Margin width factor (for bounding box):', Solver.DEFAULT_BOUNDS_MARGIN_FACTOR, FT),
        }

    @staticmethod
    def from_arguments(d):
        """
        Get a dictionary of arguments and return a solver.
        Should be overridded by solvers.

        :param d: arguments dict
        :type d: :class:`dict`
        """
        return dRRT(d['num_landmarks'], d['prm_num_landmarks'], d['prm_k'], FT(d['bounding_margin_width_factor']), None,
                    None, None)

    def get_graph(self):
        """
        Return a graph (if applicable).
        Can be overridded by solvers.

        :return: graph whose vertices are Point_2 or Point_d
        :rtype: :class:`networkx.Graph` or :class:`None`
        """
        return self.tensor_roadmap.T

    def load_scene(self, scene):
        """
        Load a scene into the solver.
        Also build the tensor roadmap.

        :param scene: scene to load
        :type scene: :class:`~discopygal.solver.Scene`
        """
        super().load_scene(scene)

        self.sampler.set_scene(scene, self._bounding_box)

        # Generate a PRM for each robot seperatly
        roadmaps = {}
        for i, robot in enumerate(self.scene.robots):
            if self.verbose:
                print('generating PRM #{}...'.format(i + 1), file=self.writer)

            if self.prm_nearest_neighbors is None or self.prm_nearest_neighbors == '':
                prm_nearest_neighbors = NearestNeighbors_sklearn()
            elif self.prm_nearest_neighbors == 'Euclidean':
                prm_nearest_neighbors = NearestNeighbors_sklearn_ball(Metric_Euclidean)
            elif self.prm_nearest_neighbors == 'CTD':
                prm_nearest_neighbors = NearestNeighbors_sklearn_ball(Metric_CTD)
            elif self.prm_nearest_neighbors == 'Epsilon_2':
                prm_nearest_neighbors = NearestNeighbors_sklearn_ball(Metric_Epsilon_2)
            elif self.prm_nearest_neighbors == 'Epsilon_Inf':
                prm_nearest_neighbors = NearestNeighbors_sklearn_ball(Metric_Epsilon_Inf)
            elif self.prm_nearest_neighbors == 'Max_L2':
                prm_nearest_neighbors = NearestNeighbors_sklearn_ball(Metric_Max_L2)
            else:
                print('Unknown metric')
                exit(-1)

            roadmaps[robot] = build_probabilistic_roadmap(
                self.scene, robot,
                self.prm_num_landmarks, self.prm_k,
                prm_nearest_neighbors, self.sampler)

        if self.nearest_neighbors is None or self.nearest_neighbors == '':
            roadmap_nearest_neighbors = NearestNeighbors_sklearn()
        elif self.nearest_neighbors == 'Euclidean':
            roadmap_nearest_neighbors = NearestNeighbors_sklearn_ball(Metric_Euclidean)
        elif self.nearest_neighbors == 'CTD':
            roadmap_nearest_neighbors = NearestNeighbors_sklearn_ball(Metric_CTD)
        elif self.nearest_neighbors == 'Epsilon_2':
            roadmap_nearest_neighbors = NearestNeighbors_sklearn_ball(Metric_Epsilon_2)
        elif self.nearest_neighbors == 'Epsilon_Inf':
            roadmap_nearest_neighbors = NearestNeighbors_sklearn_ball(Metric_Epsilon_Inf)
        elif self.nearest_neighbors == 'Max_L2':
            roadmap_nearest_neighbors = NearestNeighbors_sklearn_ball(Metric_Max_L2)
        else:
            print('Unknown metric')
            exit(-1)

        # Construct the tensor roadmap
        self.tensor_roadmap = TensorRoadmap(roadmaps, roadmap_nearest_neighbors, self.metric)

        # Convert the start and end endpoints to Point_d
        self.start_points = []
        self.end_points = []
        for robot in self.tensor_roadmap.robots:
            if type(robot) is RobotRod:
                self.start_points.append(robot.start[0])
                self.end_points.append(robot.end[0])
            else:
                self.start_points.append(robot.start)
                self.end_points.append(robot.end)
        self.start_points = conversions.Point_2_list_to_Point_d(self.start_points)
        self.end_points = conversions.Point_2_list_to_Point_d(self.end_points)

        # Add the start vertex to the RRT
        self.tensor_roadmap.add_tensor_vertex(self.start_points)

        # Add the given amount of landmarks to the RRT
        # EXPAND(T)
        cnt = 0
        while cnt <= self.num_landmarks:
            # q_rand <-- RANDOM_SAMPLE()
            q_rand = []
            for _ in self.tensor_roadmap.robots:
                q_rand.append(self.sampler.sample())
            q_rand = conversions.Point_2_list_to_Point_d(q_rand)

            # q_near <-- NEAREST_NEIGHBOR(T, q_rand)
            q_near = self.tensor_roadmap.nearest_tensor_vertex(q_rand)

            # q_new <-- O_D(q_near, q_rand)
            # if q_new \not\in R then
            #       T.add_vertex(q_new)
            #       T.add_edge(q_near, q_new)
            # NOTE: in original paper there is no treatment for when the "oracle"
            #       doesn't return a valid edge, here we just ignore and try again
            added = self.tensor_roadmap.find_best_edge(q_near, q_rand)

            if added:
                cnt += 1
                if cnt % 100 == 0 and self.verbose:
                    print('added', cnt, 'landmarks in dRRT', file=self.writer)

        # Finally try to connect to the end point
        self.tensor_roadmap.add_tensor_vertex(self.end_points)
        neighbors = self.tensor_roadmap.nearest_neighbors.k_nearest(self.end_points, self.prm_k + 1)
        for neighbor in neighbors:
            if neighbor != self.end_points:
                self.tensor_roadmap.try_connecting(neighbor, self.end_points)

    def solve(self):
        """
        Based on the start and end locations of each robot, solve the scene
        (i.e. return paths for all the robots)

        :return: path collection of motion planning
        :rtype:  :class:`~discopygal.solvers.PathCollection`
        """
        if not nx.algorithms.has_path(self.tensor_roadmap.get_tensor_subgraph(), self.start_points, self.end_points):
            if self.verbose:
                print('no path found...', file=self.writer)
            return PathCollection()

        # Convert from a sequence of Point_d points to PathCollection
        tensor_path = nx.algorithms.shortest_path(self.tensor_roadmap.get_tensor_subgraph(),
                                                  self.start_points, self.end_points, weight='weight')
        path_collection = PathCollection()
        for i, robot in enumerate(self.tensor_roadmap.robots):
            points = []
            for point in tensor_path:
                points.append(PathPoint(Point_2(point[2 * i], point[2 * i + 1])))
            path = Path(points)
            path_collection.add_robot_path(robot, path)

        if self.verbose:
            print('successfully found a path...', file=self.writer)

        return path_collection

class BasicDRRTForExperiments(dRRT):
    """ Basic DRRT for experiments"""

    def load_scene(self, scene: Scene):
        """
        Load the scene for the DRRT algorithm
        :param scene
        :type scene: :class:`~discopygal.solvers.Scene`
        """
        super().load_scene(scene)

    def solve(self) -> PathCollection:
        """
        Solve the scene using the DRRT algorithm
        :return: Path solution
        :rtype: :class:`~discopygal.solvers.PathCollection`
        """
        path = super().solve()
        return path
